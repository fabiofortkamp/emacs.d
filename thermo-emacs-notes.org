* Introduction

These are the configuration related to my note-taking workflow, mainly based on deft and markdown mode

First, do the initial setting for markdown mode.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/markdown-mode/")
(require 'markdown-mode)
(autoload 'markdown-mode "markdown-mode"
       "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.txt\\'" . markdown-mode))
#+END_SRC

Enable its math- mode:

#+BEGIN_SRC emacs-lisp
(markdown-enable-math)
#+END_SRC

* Modifying list continuation in Markdown mode

I would like to use automatic list continuation; i.e. when I press enter on a list, it creates a new list item. First we need a function to detect if we are inside a list; I use a function from the markdown mode that returns a list containing some parameters (such as marker used, indentation etc), and /returns nil if point is not inside a list/.

#+BEGIN_SRC emacs-lisp
(defun thermo-emacs-markdown-inside-list-p ()
      "Return t if point inside list item, nil if it is not."
     (if (markdown-cur-list-item-bounds) t nil))
#+END_SRC

Now we are ready to define this general "enter" function:

#+BEGIN_SRC emacs-lisp
(defun thermo-emacs-markdown-enter-key ()
      "If point is inside markdown list, insert new list item, otherwise handle RET according to value of markdown-indent-on-enter"
      (interactive)
      (if (thermo-emacs-markdown-inside-list-p)
          (markdown-insert-list-item 1)
        (if markdown-indent-on-enter (newline-and-indent) (newline))
    ))
#+END_SRC    

Finally, we bind "RET" to this function.

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook
                 (lambda ()
                   (define-key markdown-mode-map (kbd "<return>")
                               'thermo-emacs-markdown-enter-key)))



#+END_SRC

* Configure deft mode

Now, configure deft mode. I use the "extended version", which enables multiple file extensions and modes. I use markdown as default.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/deft/")
(require 'deft)

(setq deft-extensions '("txt" "org" "taskpaper" "md"))
(setq deft-default-extension "md")
(setq deft-directory "~/Dropbox/notes")
(setq deft-text-mode 'markdown-mode)

(setq deft-use-filename-as-title t)
#+END_SRC

This is a function that concatenates three deft functions. When executed, it will present the Deft buffer, clear the filter string, and query us what we want to search.

#+BEGIN_SRC emacs-lisp
  (defun thermo-emacs-deft-search ()
    "Open the deft buffer, clear the seach string and prompt for a new search string in minibuffer"
    (interactive)
    (deft)
    (deft-filter-clear)
    (call-interactively 'deft-filter)
)
#+END_SRC

We now set a global keywork to this function. This is my preferred behaviour; when I invoke Deft, I want to search for new files, and not retain the filtered list.

#+BEGIN_SRC emacs-lisp
(global-set-key [f8] 'thermo-emacs-deft-search)
#+END_SRC

* Functions to create and access notes

Let us define a function to prompt for a tile and create a new note.

This workflow follows the [[http://zettelkasten.de][zettelkasten methodology]].

Define the function and make it interactive

#+BEGIN_SRC emacs-lisp
  (defun thermo-emacs-create-zettel ()
    "Prompt for a note title and automatically creates one in `deft-directory', with a zettel ID appended to the file name, and `deft-default-extension' appended"
    (interactive)
#+END_SRC

Now, store the name in a string, reading it from the minibuffer:
#+BEGIN_SRC emacs-lisp
  (let (zettel-title zettel-id zettel-file-name)
    (setq zettel-title
          (read-string "Note title: "))
#+END_SRC

Now, create the datestamp the "zettel ID".

#+BEGIN_SRC emacs-lisp
  (setq zettel-id (format-time-string "%Y%m%d%H%M%S"))
#+END_SRC

Build the complete file name:

#+BEGIN_SRC emacs-lisp
    (setq zettel-file-name 
  (expand-file-name (concat zettel-id " " zettel-title "." deft-default-extension) deft-directory))
#+END_SRC

Finally, open the file

#+BEGIN_SRC emacs-lisp
  (find-file zettel-file-name)
#+END_SRC

Close the ~let~ and ~defun~ blocks
#+BEGIN_SRC emacs-lisp
))
#+END_SRC

Let us define a global key to use that function:

#+BEGIN_SRC emacs-lisp
(global-set-key [f5] 'thermo-emacs-create-zettel)
#+END_SRC


Another useful function to have is, if the point is inside a zettel ID, open the associated note. Let us begin with an auxiliary function:

#+BEGIN_SRC emacs-lisp
  (defun thermo-emacs-open-zettel-from-id (zettel-id)
    "Open the note associated with zettel-id; if there is none, displays an error message"
    (if (not (numberp zettel-id))
        (error "The provided zettel ID is not a number"))

    (let (matched-files target-file)
    
#+END_SRC

Fortunately, Emacs has a helpful function to list the files in a directory which matches a regex (~directory-files~).

#+BEGIN_SRC emacs-lisp
  (setq matched-files (directory-files deft-directory t (number-to-string zettel-id)))
#+END_SRC

If there is no matched files, quit

#+BEGIN_SRC emacs-lisp
  (if (not matched-files)
      (error "Could not find any files matching this ID"))
#+END_SRC


In my tests, I found that files ended in '~' are included, so sometimes we have more than one match. At this point, we always pick the first match

#+BEGIN_SRC emacs-lisp
(setq target-file (nth 0 matched-files))
#+END_SRC

Finally, we find the file, and close the funcion.

#+BEGIN_SRC emacs-lisp
(find-file target-file)
))

#+END_SRC

Next, we define an interface to that function, by calling the above function and reading the id at point:

#+BEGIN_SRC emacs-lisp
    (defun thermo-emacs-open-zettel-from-id-at-point ()
        "Open the zettel (in `deft-directory') associated with ID at point"
      (interactive)
      (thermo-emacs-open-zettel-from-id (thing-at-point 'number))
      )
#+END_SRC

In my system, my "notes" or "zettel" are markdown notes. So, to prevent conflicts, I define a keybing in markdown-mode to call this function.

#+BEGIN_SRC emacs-lisp
  (define-key markdown-mode-map (kbd "C-c f") 'thermo-emacs-open-zettel-from-id-at-point)
#+END_SRC
